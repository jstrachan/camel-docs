h2. Part 2

h2. Adding Camel
In this part we will introduce Camel so we start by adding Camel to our pom.xml:
{code:xml}
       <properties>
            ...
            <camel-version>1.4.0</camel-version>
        </properties>

        <!-- camel -->
        <dependency>
            <groupId>org.apache.camel</groupId>
            <artifactId>camel-core</artifactId>
            <version>${camel-version}</version>
        </dependency>
{code}

That's it, only *one* dependency for now.
{tip:title=Synchronize IDE}
If you continue from part 1, remember to update your editor project settings since we have introduce new .jar files. For instance IDEA has a feature to synchronize with Maven projects.
{tip}

Now we turn towards our webservice endpoint implementation where we want to let Camel have a go at the input we receive. As Camel is very non invasive its basically a .jar file then we can just grap Camel but creating a new instance of {{DefaultCamelContext}} that is the hearth of Camel its context.
{code:java}
CamelContext camel = new DefaultCamelContext();
{code}

In fact we create a constructor in our webservice and add this code:
{code:java}
    private CamelContext camel;

    public ReportIncidentEndpointImpl() throws Exception {
        // create the camel context that is the "heart" of Camel
        camel = new DefaultCamelContext();

        // add the log component
        camel.addComponent("log", new LogComponent());

        // start Camel
        camel.start();
    }
{code}

h2. Logging the "Hello World"
Here at first we want Camel to log the *givenName* and *familyName* parameters we receive, so we add the {{LogComponent}} with the key *log*. And we must *start* Camel before its ready to act.
{tip:title=Component Documentation}
The [Log] and [File] components is documented as well, just click on the links. Just return to this documentation later when you must use these components for real.
{tip}
Then we change the code in the method that is invoked by Apache CXF when a webservice request arrives. We get the name and let Camel have a go at it in the new method we create *sendToCamel*:
{code:java}
    public OutputReportIncident reportIncident(InputReportIncident parameters) {
        String name = parameters.getGivenName() + " " + parameters.getFamilyName();

        // let Camel do something with the name
        sendToCamelLog(name);

        OutputReportIncident out = new OutputReportIncident();
        out.setCode("OK");
        return out;
    }
{code}

Next is the Camel code. At first it looks like there are many code lines to do a simple task of logging the name - yes it is. But later you will in fact realize this is one of Camels true power. Its concise API. Hint: The same code can be used for *any* component in Camel.
{code:java}
    private void sendToCamelLog(String name) {
        try {
            // get the log component
            Component component = camel.getComponent("log");

            // create an endpoint and configure it.
            // Notice the URI parameters this is a common pratice in Camel to configure
            // endpoints based on URI.
            // com.mycompany.part2 = the log category used. Will log at INFO level as default
            Endpoint endpoint = component.createEndpoint("log:com.mycompany.part2");

            // create an Exchange that we want to send to the endpoint
            Exchange exchange = endpoint.createExchange();
            // set the in message payload (=body) with the name parameter
            exchange.getIn().setBody(name);

            // now we want to send the exchange to this endpoint and we then need a producer
            // for this, so we create and start the producer.
            Producer producer = endpoint.createProducer();
            producer.start();
            // process the exchange will send the exchange to the log component, that will process
            // the exchange and yes log the payload
            producer.process(exchange);

            // stop the producer, we want to be nice and cleanup
            producer.stop();




        } catch (Exception e) {
            // we ignore any exceptions and just rethrow as runtime
            throw new RuntimeException(e);

        }
    }
{code}
Okay there are code comments in the code block above that should explain what is happening. We run the code by invoking our unit test with maven {{mvn test}}, and we should get this log line:

{code}
INFO: Exchange[BodyType:String, Body:Claus Ibsen]
{code}

h2. Write to file - easy with the same code style
Okay that isn't to impressive, Camel can log ;) Well I promised that the above code style can be used for *any* component, so let's store the payload in a file. We do this by adding the file component to the Camel context
{code:java}
        // add the file component
        camel.addComponent("file", new FileComponent());
{code}

And then we let camel write the payload to the file after we have logged, by creating a new method *sendToCamelFile*. We want to store the payload in filename with the incident id so we need this parameter also:
{code:java}
        // let Camel do something with the name
        sendToCamelLog(name);
        sendToCamelFile(parameters.getIncidentId(), name);
{code}

And then the code that is 99% identical. We have change the URI configuration when we create the endpoint as we pass in configuration parameters to the file component.
And then we need to set the output filename and this is done by adding a special header to the exchange. That's the only difference:
{code:java}
    private void sendToCamelFile(String incidentId, String name) {
        try {
            // get the file component
            Component component = camel.getComponent("file");

            // create an endpoint and configure it.
            // Notice the URI parameters this is a common pratice in Camel to configure
            // endpoints based on URI.
            // file://target instructs the base folder to output the files. We put in the target folder
            // then its actumatically cleaned by mvn clean
            Endpoint endpoint = component.createEndpoint("file://target");

            // create an Exchange that we want to send to the endpoint
            Exchange exchange = endpoint.createExchange();
            // set the in message payload (=body) with the name parameter
            exchange.getIn().setBody(name);

            // now a special header is set to instruct the file component what the output filename
            // should be
            exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, "incident-" + incidentId + ".txt");

            // now we want to send the exchange to this endpoint and we then need a producer
            // for this, so we create and start the producer.
            Producer producer = endpoint.createProducer();
            producer.start();
            // process the exchange will send the exchange to the file component, that will process
            // the exchange and yes write the payload to the given filename
            producer.process(exchange);

            // stop the producer, we want to be nice and cleanup
            producer.stop();
        } catch (Exception e) {
            // we ignore any exceptions and just rethrow as runtime
            throw new RuntimeException(e);
        }
    }
{code}

After running our unit test again with {{mvn test}} we have a output file in the target folder:
{code}
D:\demo\part-two>type target\incident-123.txt
Claus Ibsen
{code}

h2. Fully java based configuration of endpoints
In the file example above the configuration was URI based. What if you want 100% java setter based style, well this is of course also possible. We just need to cast to the component specific endpoint and then we have all the setters available:
{code:java}
            // create the file endpoint, we cast to FileEndpoint because then we can do
            // 100% java settter based configuration instead of the URI sting based
            // must pass in an empty string, or part of the URI configuration if wanted 
            FileEndpoint endpoint = (FileEndpoint)component.createEndpoint("");
            endpoint.setFile(new File("target/subfolder"));
            endpoint.setAutoCreate(true);
{code}
That's it. Now we have used the setters to configure the {{FileEndpoint}} that it should store the file in the folder target/subfolder. Of course Camel now stores the file in the subfolder.
{code}
D:\demo\part-two>type target\subfolder\incident-123.txt
Claus Ibsen
{code}

h2. Lessons learned
Okay I wanted to demonstrate how you can be in 100% control of the configuration and usage of Camel based on plain Java code with no hidden magic or special *XML* or other configuration files. Just add the camel-core.jar and you are ready to go.

You must have noticed that the code for sending a message to a given endpoint is the same for both the *log* and *file*, in fact *any* Camel endpoint. You as the client shouldn't bother with component specific code such as file stuff for file components, jms stuff for JMS messaging etc. This is what the [Message Endpoint] EIP pattern is all about and Camel solves this very very nice - a key pattern in Camel.

h2. Reducing code lines
Now that you have been introduced to Camel and one of its masterpiece patterns solved elegantly with the [Message Endpoint] its time to give productive and show a solution in fewer code lines, in fact we can get it down to 5, 4, 3, 2 .. yes only *1 line of code*.

The key is the *ProducerTemplate* that is a Spring'ish xxxTemplate based producer. Meaning that it has methods to send messages to any Camel endpoints. First of all we need to get hold of such a template and this is done from the CamelContext

{code:java}
    private ProducerTemplate template;

    public ReportIncidentEndpointImpl() throws Exception {
        ...

        // get the ProducerTemplate thst is a Spring'ish xxxTemplate based producer for very
        // easy sending exchanges to Camel.
        template = camel.createProducerTemplate();

        // start Camel
        camel.start();
    }
{code}

Now we can use *template* for sending payloads to any endpoint in Camel. So all the logging gabble can be reduced to:
{code:java}
    template.sendBody("log:com.mycompany.part2.easy", name);
{code}

And the same goes for the file, but we must also send the header to instruct what the output filename should be:
{code:java}
    String filename = "easy-incident-" + incidentId + ".txt";
    template.sendBodyAndHeader("file://target/subfolder", name, FileComponent.HEADER_FILE_NAME, filename);
{code}

h2. Reducing even more code lines
Well we got the Camel code down to 1-2 lines for sending the message to the component that does all the heavy work of wring the message to a file etc. But we still got 5 lines to initialize Camel.
{code:java}
    camel = new DefaultCamelContext();
    camel.addComponent("log", new LogComponent());
    camel.addComponent("file", new FileComponent());
    template = camel.createProducerTemplate();
    camel.start();
{code}
This can also be reduced. All the standard components in Camel is auto discovered on-the-fly so we can remove these code lines and we are down to 3 lines.

{info:title=Component auto discovery}
When an endpoint is requested with a scheme that Camel hasn't seen before it will try to look for it in the classpath. It will do so by looking for special Camel component marker files that reside in the folder {{META-INF/services/org/apache/camel/component}}. If there are files in this folder it will read them as the filename is the *scheme* part of the URL. For instance the *log* component is defined in this file {{META-INF/services/org/apache/component/log}} and its content is:
{code}
class=org.apache.camel.component.log.LogComponent
{code}
The class property defines the component implementation.

*Tip:* End-users can create their 3rd party components using the same technique and have them been auto discovered on-the-fly.
{info}

Okay back to the 3 code lines:
{code:java}
    camel = new DefaultCamelContext();
    template = camel.createProducerTemplate();
    camel.start();
{code}
Later will we see how we can reduce this to ... in fact 0 java code lines. But the 3 lines will do for now.

h2. Message Translation
Okay lets head back to the over goal of the integration. Looking at the EIP diagrams at the introduction page we need to be able to translate the incoming webservice to an email. Doing so we need to create the email body. When doing the message translation we could put up our sleeves and do it manually in pure java with a StringBuilder such as:
{code:java}
    private String createMailBody(InputReportIncident parameters) {
        StringBuilder sb = new StringBuilder();
        sb.append("Incident ").append(parameters.getIncidentId());
        sb.append(" has been reported on the ").append(parameters.getIncidentDate());
        sb.append(" by ").append(parameters.getGivenName());
        sb.append(" ").append(parameters.getFamilyName());
        
        // and the rest of the mail body with more appends to the string builder
        
        return sb.toString();
    }
{code}
But as always it is a hardcoded template for the mail body and the code gets kinda ugly if the mail message has to be a bit more advanced. But of course it just works out-of-the-box with just classes already in the JDK.

Lets use a template language instead such as [Apache Velocity|http://velocity.apache.org/]. As Camel have a component for [Velocity] integration we will use this component. Looking at the [Component List|component] overview we can see that camel-velocity component uses the artifactId *camel-velocity* so therefore we need to add this to the *pom.xml*

{code:xml}
        <dependency>
            <groupId>org.apache.camel</groupId>
            <artifactId>camel-velocity</artifactId>
            <version>${camel-version}</version>
        </dependency>
{code}

And now we have a Spring conflict as Apache CXF is dependent on Spring 2.0.8 and camel-velocity is dependent on Spring 2.5.5. To remedy this we could wrestle with the *pom.xml* with excludes settings in the dependencies or just bring in another dependency *camel-spring*:

{code:xml}
        <dependency>
            <groupId>org.apache.camel</groupId>
            <artifactId>camel-spring</artifactId>
            <version>${camel-version}</version>
        </dependency>
{code}

In fact camel-spring is such a vital part of Camel that you will end up using it in nearly all situations - we will look into how well Camel is seamless integration with Spring in part 3. For now its just another dependency. 

We create the mail body with the Velocity template and create the file {{src/main/resources/MailBody.vm}}. The content in the *MailBody.vm* file is:
{code}
Incident $body.incidentId has been reported on the $body.incidentDate by $body.givenName $body.familyName.

The person can be contact by:
- email: $body.email
- phone: $body.phone

Summary: $body.summary

Details:
$body.details

This is an auto generated email. You can not reply.
{code}

Letting Camel creating the mail body and storing it as a file is as easy as the following 3 code lines:
{code:java}
    private void generateEmailBodyAndStoreAsFile(InputReportIncident parameters) {
        // generate the mail body using velocity template
        // notice that we just pass in our POJO (= InputReportIncident) that we
        // got from Apache CXF to Velocity.
        Object response = template.sendBody("velocity:MailBody.vm", parameters);
        // Note: the response is a String and can be cast to String if needed

        // store the mail in a file
        String filename = "mail-incident-" + parameters.getIncidentId() + ".txt";
        template.sendBodyAndHeader("file://target/subfolder", response, FileComponent.HEADER_FILE_NAME, filename);
    }
{code}

What is impressive is that we can just pass in our POJO object we got from Apache CXF to Velocity and it will be able to generate the mail body with this object in its context. Thus we don't need to prepare *anything* before we let Velocity loose and generate our mail body. Notice that the *template* method returns a object with out response. This object contains the mail body as a String object. We can cast to String if needed. 

If we run our unit test with {{mvn test}} we can in fact see that Camel has produced the file and we can type its content:
{code}
D:\demo\part-two>type target\subfolder\mail-incident-123.txt
Incident 123 has been reported on the 2008-07-16 by Claus Ibsen.

The person can be contact by:
- email: davsclaus@apache.org
- phone: +45 2962 7576

Summary: bla bla

Details:
more bla bla

This is an auto generated email. You can not reply.
{code}

h2. First part of the solution
What we have seen here is actually what it takes to build the first part of the integration flow. Receiving a request from a webservice, transform it to a mail body and store it to a file, and return an OK response to the webservice. All possible within 10 lines of code. So lets wrap it up here is what it takes:

{code:java}
/**
 * The webservice we have implemented.
 */
public class ReportIncidentEndpointImpl implements ReportIncidentEndpoint {

    private CamelContext camel;
    private ProducerTemplate template;

    public ReportIncidentEndpointImpl() throws Exception {
        // create the camel context that is the "heart" of Camel
        camel = new DefaultCamelContext();

        // get the ProducerTemplate thst is a Spring'ish xxxTemplate based producer for very
        // easy sending exchanges to Camel.
        template = camel.createProducerTemplate();

        // start Camel
        camel.start();
    }

    public OutputReportIncident reportIncident(InputReportIncident parameters) {
        // transform the request into a mail body
        Object mailBody = template.sendBody("velocity:MailBody.vm", parameters);

        // store the mail body in a file
        String filename = "mail-incident-" + parameters.getIncidentId() + ".txt";
        template.sendBodyAndHeader("file://target/subfolder", mailBody, FileComponent.HEADER_FILE_NAME, filename);

        // return an OK reply
        OutputReportIncident out = new OutputReportIncident();
        out.setCode("OK");
        return out;
    }

}
{code}
Okay I missed by one, its in fact only *9 lines of java code and 2 fields*.

h2. End of part 2
I know this is a bit different introduction to Camel to how you can start using it in your projects just as a plain java .jar framework that isn't invasive at all. I took you through the coding parts that requires 6 - 10 lines to send a message to an endpoint, buts it's important to show the [Message Endpoint] EIP pattern in action and how its implemented in Camel. Yes of course Camel also has to one liners that you can use, and will use in your projects for sending messages to endpoints. This part has been about good old plain java, nothing fancy with Spring, XML files, auto discovery, OGSi or other new technologies. I wanted to demonstrate the basic building blocks in Camel and how its setup in pure god old fashioned Java. There are plenty of eye catcher examples with one liners that does more than you can imagine - we will come there in the later parts. 

Okay part 3 is about building the last pieces of the solution and now it gets interesting since we have to wrestle with the event driven consumer.
Brew a cup of coffee, tug the kids and kiss the wife, for now we will have us some fun with the Camel. See you in part 3.

h2. [#Resources]
* {attachments:patterns=.*part-two.zip}

h2. Links
- [Introduction|Tutorial-Example-ReportIncident]
- [Part 1|Tutorial-Example-ReportIncident-Part1]
- [Part 2|Tutorial-Example-ReportIncident-Part2]
- [Part 3|Tutorial-Example-ReportIncident-Part3]
- [Part 4|Tutorial-Example-ReportIncident-Part4]
- [Part 5|Tutorial-Example-ReportIncident-Part5]